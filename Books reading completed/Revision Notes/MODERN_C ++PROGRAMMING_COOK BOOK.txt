1. Learning Modern Core Language Features
	1. Using auto whenever possible
		1. Using auto ensures that you always use the intended type and that implicit conversion will not occur. 
		2. The auto specifier is only a placeholder for the type, not for the const/volatile and reference specifiers. If you need a const/volatile and/or a reference type, then you need to specify them explicitly. 
		3. It is not possible to use auto for types that are not moveable:
			auto ai = std::atomic<int>(42); // error
		4. It is not possible to use auto for multi-word types, such as long long, long double, or struct foo. 
			auto l1 = long long{ 42 }; // error
			using llong = long long;
			auto l2 = llong{ 42 }; // OK
			auto l3 = 42LL; // OK
			auto l4 = (long long){ 42 }; // OK with gcc/clang
		5. auto cannot detect the return type as ref, it just take type, to have exact type we have to use decltype(auto)
			decltype(auto) proxy_get(foo& f)
			{ return f.get(); }
			auto f = foo{ 42 };
			decltype(auto) x = proxy_get(f);
			
	2. Creating type aliases and alias templates
		1. using, typedef
		2. Alias templates cannot be partially or explicitly specialized.
		3. The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type.
	3. Understanding uniform initialization
		1. T object {other}; // direct-list-initialization
		2. T object = {other}; // copy-list-initialization, don;t use it 
		3. Allocating 2D array in C++, Note the syntax.
			int (*x)[4] = new int [3][4];
			auto x = new int[3][4];
		4. int* arr2 = new int[3]{ 1, 2, 3 };
		5. For initializer list syntax all data member must be present in constructor initialisation (if we don't have initializer list syntax still we can use {} syntax provided we should have a constructor initializating all members
			ex. foo():a_(0), b_(0) {}
				foo(int a, double b = 0.0):a_(a), b_(b) {}
			usage
				foo f2{ 42, 1.2 };
				foo f3{ 42 };
		6. foo(std::initializer_list<int> l) {}, how it works
			compiler creates an array with the elements in the initializer list.
			The compiler creates an std::initializer_list<T> object to wrap the previously created array.
		7. Another thing to note is that brace-initialization does not allow narrowing (implicit) conversion.
			int i{ 1.2 }; // error
	4. Understanding the various forms of non-static member initialization
		1. It is important to note that the order in which non-static data members are initialized is the order in which they were declared in the class definition, not the order of their initialization in a constructor initializer list. Conversely, the order in which non-static data members are destroyed is the reversed order of construction.
	5. Controlling and querying object alignment
		1. Intel Streaming SIMD Extensions (SSE) and Intel SSE2, which are a set of processor instructions that can greatly increase performance when the same operations are to be applied on multiple data objects, require 16 bytes of alignment of data
		2.  Intel Advanced Vector Extensions (or Intel AVX), which expands most integer processor commands to 256 bits, it is highly recommended to use 32-byte alignment.
		3. struct alignas(4) foo, alignas(2) char a;
		4. misaligned, the compiler has to do extra work to access data; it has to read multiple chunks of data, shift and discard unnecessary bytes, and combine the rest.
		5. objects is aligned to it's highest size of data member available.
			ex. struct foo1 {char a} // size = 1, alignment = 1
				struct foo1 {char a, b} // size = 2, alignment = 1
				struct foo1 {char a, int b} // size = 8, alignment = 4
				struct foo1 {char a, double x, int b} // size = 24, alignment = 8
		6. The only valid alignments are the powers of two (1, 2, 4, 8, 16, 32, and so on). Any other values are illegal, and the program is considered ill-formed
		7. If the largest alignas on a declaration is smaller than the natural alignment without any alignas specifier, then the program is also considered ill-formed
			ex. Means struct alignas(4) foo { double  d} // its natural alignment is 8
		8.  alignof
	6. Using scoped enumerations
		1. In C++23, you can convert to the underlying type of a scoped enumeration by using the std::to_underlying() utility function:
			ex.
			void old_api(unsigned flag)
			enum class user_rights : unsigned
			old_api(std::to_underlying(user_rights::Read));
		2. C++23 is a type trait called is_scoped_enum<T>, 
	7. Using override and final for virtual methods
	8. Using range-based for loops to iterate on a range
		1. In C++20, the code generated by the compiler is slightly different:
			{
				init-statement
				auto && __range = range_expression;
				auto __begin = begin_expr;
				auto __end = end_expr;
				for (; __begin != __end; ++__begin) {
				range_declaration = *__begin;
				loop_statement
				}
			}
		2. The new standard has removed the constraint that the begin expression and the end expression must be the same type. The end expression does not need to be an actual iterator, but it has to be able to be compared for inequality with an iterator. 
		3. Conversely, the end expression is only evaluated once, and not every time the loop is iterated, which could potentially increase performance
		4. // undefined behavior, until C++23
			for (int rate : make_item().getRates())
			{
				std::cout << rate << '\n';
			}
			Since make_item() returns by value, we have a temporary within range-expression. This introduces undefined behavior, which can be avoided with an initialization statement,
				ex. for (auto item = make_item(); int rate : item.getRates())
			This problem no longer manifests in C++23, because this version of the standard also extends the lifetime of all the temporaries within the range-expression until the end of the loop.
	9. Enabling range-based for loops for custom types
		1. operator++ (both the prefix and the postfix version)
		2. operator* for dereferencing 
		3. operator!= for comparing the iterator with another iterator for inequality
		4. Provide free begin() and end() functions for the type
	10. Using explicit constructors and conversion operators to avoid implicit conversion
		1. With C++11, every constructor without the explicit specifier is considered a converting constructor. 
		2. Not just constructor, operator can be explicit
			explicit handle_t(int const h) : handle(h) {}
			explicit operator bool() const { return handle != 0; };
		3. With explicit constructors, the compiler is able to immediately flag erroneous situations 
		4. when conversion operator marked as explicit then we have to use explicit static_cast  to make it conversation else it will not work
	11. Using unnamed namespaces instead of static globals
		1. by declaring global variable as static it's scope is limit to local translation unit
		2. don't put static in unnamed namespace, it's meaning less
		3. When a function is declared in a translation unit, it has an external linkage. This means two functions with the same name from two different translation units would generate a linkage error because it
		4. For unnamed namespace, compiler generate the name, ex.
			namespace _unique_name_ {}
		5. is not possible to have two symbols with the same name.
	12. Using inline namespaces for symbol versioning
		1. helpful feature for library versioning, and in this recipe, 
		2. using inline namespace, test appears to be under modernlib namespace directly and not under modernize::version_1 
		 Hence internal implementation are hidden from client  
		 Client use as modernlib::test so it does not break when new version is added
		namespace modernlib
		{
			namespace version_1
			{
				template<typename T>
				int test(T value) { return 1; }
			}

			inline namespace version_2
			{
				template<typename T>
				int test(T value) { return 2; }
			}
		}
		3. A member of an inline namespace is treated as if it were a member of the surrounding namespace. 
		4. This is a transitive property, which means that if a namespace, A, contains an inline namespace, B, that contains an inline namespace, C, then the members of C appear as they were members of both B and and the members of B appear as they were members of A.
		due to linlined namespace.
		5. client needs to be aware of those in order to do template specialization. These internal details are hidden with inline namespaces
	13. Using structured bindings to handle multi-return values
		1. structured bindings and std::tie() are same
		2. auto [it, inserted] = m.insert
			std::tie(it, inserted) = m.insert
		3. The new C++20 standard has introduced a series of improvements to structure bindings, including
			the following:
			• The possibility to include the static or thread_local storage-class specifiers in the declaration
			of the structure bindings.
			• The use of the [[maybe_unused]] attribute for the declaration of a structured binding. Some
			compilers, such as Clang and GCC, had already supported this feature.
			• The possibility to capture structure binding identifiers in lambdas. All identifiers, including
			those bound to bitfields, can be captured by value. Conversely, all identifiers except for those
			bound to bitfields can also be captured by reference.
		4. In C++26, it will be possible to ignore a variable by using an underscore (_) instead of a name.
	14. Simplifying code with class template argument deduction
		1. The type that the compiler deduces is std::pair<int, char const*>. If we want to instruct the compiler to deduce std::string instead of char const*, then we need several user-defined deduction rules, as shown here:
			pair(T&&, char const*)->pair<T, std::string>;
			pair(char const*, T&&)->pair<std::string, T>;
			pair(char const*, char const*)->pair<std::string, std::string>;
		2. There are some known cases where class template argument deduction does not work
			1. Aggregate templates, where you could write a user-defined deduction guide to circumvent the problem
				template<class T>
				struct Point3D { T x; T y; T z; };
				Point3D p{1, 2, 2}; // error, requires Point3D<int
			2. Type aliases, as shown in the following example (for GCC, this actually works when compiling with -std=c++20):
				template <typename T>
				using my_vector = std::vector<T>;
				std::vector v{1,2,3}; // OK
				my_vector mv{1,2,3}; // error
	15. Using the subscript operator to access elements in a collection
		1. T const& operator[](size_t const index) const
		{
			if(index >= data.size())
				std::runtime_error("invalid index");
			return data[index];
		}
		2. For multidimensional containers, in C++23, you can overload the subscript operator with multiple arguments:
			template <typename T, size_t ROWS, size_t COLS>
			T& operator[](size_t const row, size_t const col)
			{
				if(row >= ROWS || col >= COLS)
					throw std::runtime_error("invalid index");
				return data[row * COLS + col];
			}
		3. The major problem with the subscript operator was that, prior to C++23, it could only have one parameter. 
			template <typename T, size_t ROWS, size_t COLS>
			T& operator[](std::initializer_list<size_t> index)
			{
				size_t row = *index.begin();
				size_t col = *(index.begin() + 1);
				if (row >= ROWS || col >= COLS)
					throw std::runtime_error("invalid index");
				return data[row * COLS + col];
			}

2 Working with Numbers and Strings
	1. Understanding the various numeric types
		1.  std::ptrdiff_t
		2. want to optimize for fastest access, use one of the std::int_fast8_t, std::int_fast16_t, std::int_fast32_t, or std::int_fast64_t types (or their unsigned counterparts). These are guaranteed to be available on all target architectures.
		3. want to optimize the memory usage, use one of std::int_least8_t, std::int_last16_t, std::int_least32_t, or std::int_least64_t 
		4. signed short : -32,768 to 32,767. What if we want to store 32,768? 
			The decimal 32,767 is 01111111 11111111 in binary and the next value is 10000000 00000000, which, on a 16-bit representation, is -32,768 in decimal.
			As, number are represented in 2's compliment format.
		5. uint_fastX_t vs int_leastX_t 
		6. signed int are from uint_fastX_t
		7. The digit separators  : auto c = 00'12'34;, 0x..., 00..., 0b...
	2. Limits and other properties of numeric types
		1. Macros: CHAR_MIN/CHAR_MAX, INT_MIN/INT_MAX, and DBL_MIN/DBL_MAX
		2. std::bitset<std::numeric_limits<decltype(n)>::digits> bits { static_cast<unsigned long long>(n) };
		3. std::numeric_limits members
			1. digits, digits10, is_integer, is_signed, is_exact, has_infinity
	3. Converting between numeric and string types
		1.  std::stoi(), std::stol(), std::stoll(), std::stoul(), or std::stoull(), 
		2. auto i2 = std::stoi("101010"L, nullptr /*pos*/, 2); // i2 = 42 third parameter is base
		3. ston (string to number), where n stands for i (integer), l (long), ll (long long), ul (unsigned long), or ull (unsigned long long). Note: these functions also discards white spaces
		4. auto i15 = std::stoi(" +42dec", &pos);// i15 = 42, pos = 5 , it ignores des
		5. auto d6 = std::stod("1.2345e+2"); // d6 = 123.45000000000000
			auto d7 = std::stod("0xF.6E6666p3"); // d7 = 123.44999980926514, A floating-point constant in the base 2 scientific notation not hex
			optional e or E
		6. auto d8 = std::stod("INF"); // d8 = inf
			auto d9 = std::stod("-infinity"); // d9 = -inf
			auto d10 = std::stod("NAN"); // d10 = nan
			auto d11 = std::stod("-nanabc"); // d11 = -nan
	4. Understanding the various character and string types
		1. The standard does not specify whether char is a signed or unsigned type.
		2. 	w_char it is 2 bytes on Windows and typically 4 bytes on Unix systems, not portable
		3. 	auto c4 = u'd'; // char16_t
			auto c5 = U'e'; // char32_t
			auto c3 = u8'c'; // char until C++20, char8_t in C++20
			using namespace std::string_literals;
		4. \u (for 4 hexadecimal digit code points) or \U (for 8 hexadecimal digit code points
			std::u16string hb = u"Harald Bluetooth \u16BC\u16d2"; //
			std::u32string eh = U"Egyptian hieroglyphs \U00013000 \U000131B2";
			C++23, but it requires the syntax \u{n…} (with lowercase u), where n… is an arbitrary number of hexadecimal digits.
			std::u32string eh = U"Egyptian hieroglyphs \u{13000} \u{131B2}";
	5. Printing Unicode characters to the output console
		1. For UTF-8 strings stored using the char8_t data type, you can still use std::cout but must reinterpret the underlying type as an array of chars:
			std::cout << reinterpret_cast<const char*>(u8"Στέφανος Τσιτσιπάς\n");
		2. For writing UTF-16 encoded Unicode characters on a Windows system, use wchar_t characters and std::wstring strings. Make sure to call _setmode(_fileno(stdout), _O_U16TEXT) before writing to the standard output:
			auto mode = _setmode(_fileno(stdout), _O_U16TEXT);
			std::wcout << L"Erling Håland\n";
		3. code pages: The ASCII encoding requires only 7 bits for encoding the 128 characters. Therefore, an additional 128 characters are available to encode using an 8-bit data type. That means that the characters in the index 128–255 can be mapped to other languages or alphabets. Such a mapping is called a code page.
		4. UTF-8 is a variable-length character encoding standard, compatible with ASCII. UTF-8 uses 1, 2, 3, or 4 bytes to encode all the representable code points.  The first byte in the encoding is called a lead byte and provides information about how many bytes are used to encode the code point. 
	6. Generating pseudo-random numbers
		1. True randomness can only be achieved through hardware devices, 
			#include <random>
			std::random_device rd{}; //use std::random_device generator to seed a pseudo-random engine:
			auto mtgen = std::mt19937{ rd() }; //engines to generate numbers and initialize it with a random seed:
			auto ud = std::uniform_int_distribution<>{ 1, 6 }; //Use one of the available distributions
			for(auto i = 0; i < 20; ++i)
				auto number = ud(mtgen);
		2. std::normal_distribution<>{ 5, 2 } //with mean 5 and standard variance 2
	7. Properly initializing a pseudo-random number generator
		1. Use an std::random_device to produce random numbers to be used as seeding values:
			std::random_device rd;
		2. Generate random data for all internal bits of the engine:
			std::array<int, std::mt19937::state_size> seed_data {};
			std::generate(std::begin(seed_data), std::end(seed_data), std::ref(rd));
		3. Create an std::seed_seq object from the previously generated pseudo-random data:
			std::seed_seq seq(std::begin(seed_data), std::end(seed_data));
		4. Create an engine object and initialize all the bits representing the internal state of the engine; 
			for example, an mt19937 has 19,937 bits of internal state: 624 x 32 bits
			auto eng = std::mt19937{ seq };
			Note: random device and random engine are different so the engine can take seed or sequence of seed
		5. Use the appropriate distribution based on the requirements of the application:
			auto dist = std::uniform_real_distribution<>{ 0, 1 };
		6. std::mt19937, Mersenne Twister is slower than the other engines, it can produce the longest sequences of non-repeating numbers with the best spectral characteristics. 
	8. Creating cooked user-defined literals
		1. Always prefix the user-defined suffix with an underscore (_)
		2. ex. T operator "" _suffix(unsigned long long int);
			T operator "" _suffix(char const *, std::size_t);
		3. operator""h, operator""min, operator""s, operator""ms, operator""us, and operator""ns for creating an std::chrono::duration value:
			using namespace std::chrono_literals;
			// std::chrono::duration<long long>
			auto timer {2h + 42min + 15s};
			auto year { 2020y }; // std::chrono::year
			auto day { 15d }; // std::chrono::da
		4. operator""if, operator""i, and operator""il for creating an std::complex<float>, std::complex<double>, and std::complex<long double> value:
			using namespace std::complex_literals;
			auto c{ 12.0 + 4.5i }; // std::complex<double>
	9. Creating raw user-defined literals
	10. Using raw string literals to avoid escaping characters
		1. auto pattern {R"((\w+)=(\d+)$)"s};
		2. Raw string literals can be prefixed by one of L, u8, u, and U to indicate a wide, UTF-8, UTF-16, or UTF-32 string literal, respectively. The following are examples of such string literals:
			auto t1{ LR"(text)" }; // const wchar_t*
			auto t2{ u8R"(text)" }; // const char* until C++20
			// const char8_t* in C++20
			auto t3{ uR"(text)" }; // const char16_t*
			auto t4{ UR"(text)" }; // const char32_t*
	11. Creating a library of string helpers
	12. Verifying the format of a string using regular expressions
		1. #include <regex>
			auto rx = std::regex{pattern};
			auto rx = std::regex{pattern, std::regex_constants::icase};
			auto valid = std::regex_match("marius@domain.com"s, rx);
		2. There are multiple versions of regular expressions, and the C++ standard library supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and egrep (grep with the option -E). The default grammar used is ECMAScript, and in order to use another, you have to explicitly specify the grammar when defining the regular expression.
		3. The class template std::sub_match represents a sequence of characters that matches a capture group; 
		4. The class template std::match_results is a collection of matches; the first element is always a full match in the target, while the other elements are matches of subexpressions:
		5. std::regex_match(), std::regex_search(), std::regex_replace().
		6. std::regex_interator: A constant forward iterator used to iterate through the occurrences of a pattern in a string. 
		7. std::regex_token_iterator: A constant forward iterator used to iterate through the submatches of every match of a regular expression in a string.
	13. Parsing the content of a string using regular expressions
	14. Replacing the content of a string using regular expressions
		1. auto newtext = std::regex_replace(text, rx, "---"s);
		2. auto newtext = std::regex_replace(text, rx, "$2 $1"s);
			Replace string with second Sub match then first submatch
		3. $& indicates the entire match.
			• $1, $2, $3, and so on indicate the first, second, and third submatches, and so on.
			• $` indicates the part of the string before the first match.
			• $' indicates the part of the string after the last match.
		4. By default, the matching flag is std::regex_constants::match_default
		5. If we want, for instance, to replace only the first occurrence, then we can specify std::regex_constants::format_first_only. 
		6. (\b indicates a word boundary, so \ba means a word with a single letter, a)
		7. Apart from the identifiers of the subexpressions ($1, $2, and so on), there are other identifiers for the entire match ($&), the part of the string before the first match ($`), and the part of the string after the last match ($').
			auto text{"today is 1.06.2023!!"s};
			auto rx = std::regex{R"((\d{1,2})(\.|-|/)(\d{1,2})(\.|-|/)(\d{4}))"s};
			// today is 2023.06.1!!
			auto newtext1 = std::regex_replace(text, rx, R"($5$4$3$2$1)");
			// today is [today is ][1.06.2023][!!]!!
			auto newtext2 = std::regex_replace(text, rx, R"([$`][$&][$'])");
	15. Using std::string_view instead of constant string references
		1. std::string const & str, compiler may create temporary here even it is const &. Hence string view are used.
		2. An std::basic_string_view object has a relatively small size because all it needs is a pointer to the first character in the sequence and the length. It can be constructed not only from an std::basic_string object but also from a pointer and a length, or from a null-terminated sequence of characters (in which case, it will require an initial traversal of the string in order to find the length).
	16. Formatting and printing text with std::format and std::print
		1. The C++20 standard proposes a new formatting library : <format> header
		2. auto text = std::format("{} is {}", "John", 42);
			auto text = std::format("{0} is {1}", "John", 42);
			The order of the arguments is not important.
		3. auto date = std::format("Today is {:%Y-%m-%d}", now);
		4. You can also write the arguments in an out format using an iterator with either std::format_to() or std::format_to_n()
			std::vector<char> buf;
			std::format_to(std::back_inserter(buf), "{} is {}", "John", 42);
		5. Write it in buffer
			auto size = std::formatted_size("{} is {}", "John", 42); // return the final size of string after formatting
			std::vector<char> buf(size);
			std::format_to(buf.data(), "{} is {}", "John", 42);
			
			or
			char buf[100];
			auto result = std::format_to_n(buf, sizeof(buf), "{} is {}", "John", 42);
		6. In C++23, you can write formatted text directly to a file stream, such as the standard output console, using the following functions from the new <print> header:
			1. std::print
			2. std::println
		7. For user-defined types, it is defined by a user-defined specialization of the std::formatter class for the desired type.
			<: Forces the field to be left-aligned 
			>: Forces the field to be right-aligned 
			^: Forces the field to be centered with the available space.
			auto t9 = std::format("{:+05d}", 42); // "+0042"
			auto t10 = std::format("{:#05x}", 42); // "0x02a", Note the suffix d x which represent n umber format
			auto t11 = std::format("{:<05}", -42); // "-42 " ,Note 0 is leading 0 digit and 5 is width
		8. And many specialization are there, just limiting the scope here
	17. Using std::format with user-defined types	
		1. To enable formatting using the new formatting library for user-defined types, you must do the following:
			• Define a specialization of the std::formatter<T, CharT> class in the std namespace.
			• Implement the parse() method to parse the portion of the format string corresponding to the
			current argument. If the class inherits from another formatter, then this method can be omitted.
			• Implement the format() method to format the argument and write the output via format_
			context.
			in parse function we parse the format specifier If provided any , and in format function we actually format the input
			template <>
			struct std::formatter<employee>
			{
				constexpr auto parse(format_parse_context& ctx)
				{
					// add data member in the class and parase this string in ctx.
					return ctx.begin();
				}
				auto format(employee const & e, format_context& ctx) const
				{
					// once the parsed result is stored in data member, access it here to 
					// format the string
					return std::format_to(ctx.out(),
										"[{}] {} {}",
										e.id, e.firstName, e.lastName);
				}
			};
		2. If you do not need to parse the format specifier in order to support various options, you could entirely omit the parse() method. However, in order to do so, your std::formatter specialization must derive from another std::formatter class. 
			template<>
			struct std::formatter<employee> : std::formatter<char const*>
			{
				//this Syntax. means template parameter type is of employee i.e. it is specialisation
				auto format(employee const& e, std::format_context& ctx) const
				{
					return std::format_to(ctx.out(), "[{}] {} {}",
													e.id, e.firstName, e.lastName);
				}
			}

3 Exploring Functions
	1. Defaulted and deleted functions
		2. Using lambdas with standard algorithms
			[] --> conver to members of class
			() --> conver to constructor of class
			{} --> conver to defination of 'typename operator()(...) const' of class
		3. [&x...](){} Captures pack extension x by reference
			[x...](){} Captures pack extension x by copy.
			[x=expr](){} x is a data member of the lambda’s closure initialized from the expression expr
			[x, x](){} Error; x is captured twice.
			[&, &x](){} Error; everything is captured by reference, and we cannot specify again to capture x by reference.
			[&this](){} Error; the pointer this is always captured by copy.
		4. In this latter case, the correct capture should be [*this] so that the object is copied by value. In this case, invoking the lambda will print 42 john, even though the temporary has gone out of scope
			auto run()
			{
				return[this]{ std::cout << id << ' ' << name << '\n'; };
			}
			
			auto l = foo{ 42, "john" }.run();
			l(); // does not print 42 john
		5. Before C++23, attributes could be specified on a lambda expression
			auto linc = [][[nodiscard,deprecated]](int a) { return a+1; };
			auto linc = [](int a) [[deprecated]] { return a+1; };
	3. Using generic and template lambdas
		1. auto lsum = [](auto const s, auto const n) {return s + n;};
		2. auto tl = []<typename T>(std::vector<T> const& vec)
		3. With template lambda, we can rewrite it in a simpler way as follows:
			template <typename ...T>
			void foo(T&& ... args)
			{ /* ... */ }
			
			auto tl = [](auto&& ...args)
			{
				return foo(std::forward<decltype(args)>(args)...);
			}
			
			auto tl = []<typename ...T>(T && ...args)
			{
				return foo(std::forward<T>(args)...);
			}
	4. Writing a recursive lambda
		1. void sample()
			{
				std::function<int(int const)> lfib =
				[&lfib](int const n)
				{
					return n <= 2 ? 1 : lfib(n - 1) + lfib(n - 2);
				};
				auto f10 = lfib(10);
			}
			Key this is we need some variable which holds the lambda and using which we can
			call the lambda again, this can be done by 
			1. function pointer 
			2. std: : function 
			3. template and passing this pointer
		2. A recursive Fibonacci lambda expression, taking advantage of the C++23 feature called explicit
		object parameter (or deducing this), a further simplified alternative to the one above:
		void sample()
		{
			auto lfib = [](this const auto& self, int n) -> int
			{
				return n <= 2 ? 1 : self(n - 1) + self(n - 2);
			};
			lfib(5);
		}
	5. Writing function templates
		1. Function templates only support full specialization.
		2. Partial specialization is only possible for class templates. 
	6. Writing a function template with a variable number of arguments
		1. template <typename T> // [1] overload with fixed
			T add(T value) // number of arguments
			{
				return value;
			}
			template <typename T, typename... Ts> // [2] typename... Ts
			T add(T head, Ts... rest) // [3] Ts... rest
			{
				return head + add(rest...); // [4] rest...
			}
			Typename... Ts is a template parameter pack
			Ts... rest is a function parameter pack
			rest... is an expansion 
			The position of the ellipsis is not syntactically relevant. typename... Ts, typename ...Ts, and typename ...Ts are all equivalent.
		2. When the compiler encounters add(1, 2, 3, 4, 5), it generates the following functions (notice that arg1, arg2, and so on are not the actual names the compiler generates), which shows that this process	is actually only a sequence of calls to overloaded functions and not recursion:
			int add(int head, int arg1, int arg2, int arg3, int arg4)
			{return head + add(arg1, arg2, arg3, arg4);}
			int add(int head, int arg1, int arg2, int arg3)
			{return head + add(arg1, arg2, arg3);}
			int add(int head, int arg1, int arg2)
			{return head + add(arg1, arg2);}
			int add(int head, int arg1)
			{return head + add(arg1);}
			int add(int value)
			{return value;}
		3. we can use  __PRETTY_FUNCTION__ in veriadic template function to check the number of function defination generated.
		4. sizeof...(a) to get size of variable-length parameters
	7. Using fold expressions to simplify variadic function templates
		• Left folding with a unary form (... op pack):
			template <typename... Ts>
			auto add(Ts... args)
			{
				return (... + args);
			}
		• Left folding with a binary form (init op ... op pack):
			template <typename... Ts>
			auto add_to_one(Ts... args)
			{
				return (1 + ... + args);
			}
		• Right folding with a unary form (pack op ...):
			template <typename... Ts>
			auto add(Ts... args)
			{
				return (args + ...);
			}
		• Right folding with a binary form (pack op ... op init):
			template <typename... Ts>
			auto add_to_one(Ts... args)
			{
				return (args + ... + 1);
			}
			
			(... op pack)                 ((pack$1 op pack$2) op ...) op pack$n
			(init op ... op pack)         (((init op pack$1) op pack$2) op ...) op pack$n
			(pack op ...)                 pack$1 op (... op (pack$n-1 op pack$n))
			(pack op ... op init)         pack$1 op (... op (pack$n-1 op (pack$n op init)))
		2. When using the unary form, only operators such as *, +, &, |, &&, ||, and , (comma) are allowed 
	8. Implementing the higher-order functions map and fold
		1. A higher-order function is a function that takes one or more other functions as arguments and applies them to a range (a list, vector, map, tree, and so on), thus producing either a new range or a value. 
	9. Composing functions into a higher-order function
	10. Uniformly invoking anything callable
		1. auto a1 = std::invoke(add, 1, 2);
		2. std::invoke(&foo::increment_by, f, 10); // Member functions 
		3. auto x1 = std::invoke(&foo::x, f); // Data members:
		4. In practice, std:invoke() should be used in template metaprogramming to invoke a function with an arbitrary number of arguments. 
			template <class F, class T, std::size_t... I>
			auto apply(F&& f, T&& t, std::index_sequence<I...>)
			{
				return std::invoke(
				std::forward<F>(f),
				std::get<I>(std::forward<T>(t))...);
			}
		5. The standard library also provides a series of related type traits: std::is_invocable and std::is_nothrow_invocable on the one hand, and std::is_invocable_r and std::is_nothrow_invocable_r on the other hand. 
		
4 Preprocessing and Compilation
	1. Conditionally compiling your source code
		1. To check whether a language or library feature is available, use the predefined macros __cpp_xxx for language features (such as __cpp_constexpr, __cpp_constinit, or __cpp_modules) and __cpp_lib_xxx for library features (such as __cpp_lib_concepts, __cpp_lib_expected, or __cpp_lib_jthread). The library feature macros were introduced in C++20 and are available in the <version> header:
			__cpp_xxx 
			__cpp_lib_xxx
		2.  #if __has_include(<optional>)
		3. #if __has_cpp_attribute(deprecated)
		4. The #if directive requires a constant expression, whereas #ifdef and #ifndef require an identifier
		5. defined(identifier) is considered true if identifier is defined;
	2. Using the indirection pattern for preprocessor stringification and concatenation
		1. operator #, is called the stringizing operator
		2. operator ##, is called the token-pasting, merging, or concatenating operator.
		3. #define MAKE_STR2(x) #x //for creating string
		4. #define MAKE_STR(x) MAKE_STR2(x) // the indirection i.e. defining 2 macros , is done for supporting other macros
		5. #define MERGE2(x, y) x##y
			#define MERGE(x, y) MERGE2(x, y)
			At first glance, it seems unnecessary to have one macro calling another macro, but this level of indirection is key for making the # and ## operators work with other macros
	3. Performing compile-time assertion checks with static_assert
	4. Conditionally compiling classes and functions with enable_if
		1. typename= true-type or false-type can come and based on that template is enabled or disabled
			template<typename T,
				typename = typename std::enable_if_t<std::is_integral_v<T>, T>>
	5. Selecting branches at compile time with constexpr if
	6. Providing metadata to the compiler with attributes
		1. Attributes. fallthrough, nodiscard, maybe_unused, likely, unlikey, assume(C++23) (An assumption that does not hold causes undefined behavior), noreturn
		2. The [[carries_dependency]] attribute indicates that the dependency chain in release-consume std::memory_order propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.
		3. The [[no_unique_address]] attribute can be applied to non-static data members, excluding bitfields, and tells the compiler that the member does not have to have a unique address. When applied to a member that has an empty type, the compiler can optimize it to occupy no space, as in the case of it being an empty base. On the other hand, if the member’s type is not empty, the compiler may reuse any ensuing padding to store other data members
		
5 Standard Library Containers, Algorithms, and Iterators
	1. Using vector as a default container
	2. Using bitset for fixed-size sequences of bits
		1. std::bitset<8> b2{ 10 }; // [0,0,0,0,1,0,1,0]
		2. std::bitset<8> b3{ "1010"s }; // [0,0,0,0,1,0,1,0]
		3. std::bitset<8> b4 { "ooooxoxo"s, 0, std::string::npos, 'o', 'x' }; // [0,0,0,0,1,0,1,0]
		A bitset from a string containing any two characters representing '0' and '1'; in this case, we must specify which character represents a 0 (the fourth parameter, 'o') and which character represents a 1 (the fifth parameter, 'x'):
		4. bs.all(), bs.none() to check the bits set
		5. bs.test(4) / bs[4]; // to check the value of an individual bit
		6. Member operators |=, &=, ^=, and ~ to perform the binary operation OR, AND, XOR, and NOT,
		7. Member operators <<=, <<, >>=, and >> to perform shifting operations:
		8. flip() to toggle the entire set or an individual bit from 0 to 1 or from 1 to 0:
		9. bs.set(), bs.reset()
		10. to_ulong() and to_ullong() to convert to unsigned long or unsigned long long. 
		11. bs.to_string()
		12. Adding a bit flag is done with (value |= FLAG) .
		13. removing a bit flag is done with (value &= ~FLAG).
	3. Using vector<bool> for variable-size sequences of bits
		1. For this reason, however, std::vector<bool> does not meet the requirements of a standard container or sequential container, nor does std::vector<bool>::iterator meet the requirements of a forward iterator. As a result, this specialization cannot be used in generic code where a vector is expected.
		2. Dereferencing an iterator cannot produce a reference to bool for the same reason as mentioned earlier:
			auto& bit = *bv.begin(); // error
	4. Using the bit manipulation utilities
		1. unsigned char n = 0b00111100;
			auto vl1 = std::rotl(n, 0); // 0b00111100
			auto vl5 = std::rotl(n, -2);// 0b00001111 // for negative value it has rotated to opposite direction
			auto vr1 = std::rotr(n, 0); // 0b00111100
			auto vr5 = std::rotr(n, -2); // 0b11110000
		2. If you need to count the number of consecutive 0 bits (that is, until a 1 is found),
			std::cout << std::countl_zero(0b00111010u) << '\n'; // 2 , only count consecutive zeros
		3. If you need to count the number of consecutive 1 bits (that is, until a 0 is found)
			std::cout << std::countr_one(0b11000101u) << '\n'; // 1
		4. If you need to count the number of 1 bits, use std::popcount<T>().
			std::cout << std::popcount(0b00000000u) << '\n'; // 0
		5. If you need to find the smallest power of two that is greater than or equal to a given number, use std::bit_ceil<T>(). On the other hand, if you need to find the largest power of two that is smaller than or equal to a given number, use std::bit_floor<T>():
			std::cout << std::bit_ceil(0u) << '\n'; // 0
			std::cout << std::bit_floor(3u) << '\n'; // 2
			std::cout << std::bit_ceil(3u) << '\n'; // 4
		6. std::cout << std::bit_width(15u) << '\n'; // 4
		7. If you need to reinterpret the object representation of a type F as that of a type T, then use std::bit_cast<T, F>():
			const double pi = 3.1415927;
			const uint64_t bits = std::bit_cast<uint64_t>(pi);
			const double pi2 = std::bit_cast<double>(bits);
			std::cout
			<< std::fixed << pi << '\n' // 3.1415923
			<< std::hex << bits << '\n' // 400921fb5a7ed197
			<< std::fixed << pi2 << '\n'; // 3.1415923
	5. Finding elements in a range
		1. std::find...., std::min_, std::max_, std::search, std::make_boyer_moore_searcher()
		2. Use std::search_n() to search for N consecutive occurrences of a value in a range;
			auto it = std::search_n(v.cbegin(), v.cend(), 2, 0); //Basically find the sequence
		3. Use std::adjacent_find() to find two adjacent elements in a range that are equal or satisfy a binary predicate;
		4. Use std::lower_bound() to find the first element in a range not less than a specified value; this algorithm returns an iterator to the element:
		5. Use std::upper_bound() to find the first element in a range greater than a specified value;
		6. Use std::equal_range() --> {std::lower_bound(), std::upper_bound()}
	6. Sorting a range
		1. std::sort(v.begin(), v.end(), std::greater<>());
		2. Use std::stable_sort() for sorting a range but keeping the order of the equal elements:
		3. Use std::partial_sort() for sorting a part of a range (and leaving the rest in an unspecified order):
		4. Use std::partial_sort_copy() for sorting a part of a range by copying the sorted elements to a second range and leaving the original range unchanged:
		5. Use std::is_sorted_until() to find a sorted subrange from the beginning of a range:
	7. Initializing a range
		1. std::fill, fill_n, generate, generate_n, 
	8. Using set operations on a range
		1. std::set_union, std::set_merge, std::set_intersection, std::set_difference
		2. std::set_symmetric_difference() to compute a dual difference of the two ranges into a third range; the output range will contain elements that are present in any of the input ranges, but only in one:
		3. std::includes() to check if one range is a subset of another range 
	9. Using iterators to insert new elements into a container
		1. std::fill_n(std::back_inserter(v), 3, 0);
		2. std::fill_n(std::front_inserter(l), 3, 0);
		3. std::inserter() to insert anywhere in a container, for containers that have an insert()	method:
			std::fill_n(std::inserter(v, v.begin()), 3, 0);
		4. *std::back_inserter(v) = 6; 
	10. Writing your own random-access iterator
		1. Iterator class members to meet random access iterator requirements—arithmetic add and subtract, comparable for inequality
		2. check bounds for  +=, -=, [], ++, --
	11. Container access with non-member functions
		1. std::size(v1);, std::empty(v1);, std::data(v1); std::begin() and std::end() in C++11
			• std::cbegin()/std::cend(), std::rbegin()/std::rend(), and std::crbegin()/std::cren () in C++14
			• std::data(), std::size(), and std::empty() in C++17
			• std::ssize() in C++20
		2. Specializations must be defined in the same namespace where the original class or function template has been defined. Therefore, if you want to specialize any of the std::begin()/ std::end() pairs, you must do so in the std namespace.
		3. std::data() has several overloads; for a class C it returns c.data(), for arrays it returns the array, and for std::initializer_list<T> it returns the il.begin():
			template <class T, std::size_t N>
			constexpr T* data(T (&array)[N]) noexcept
			{
				return array;
			}
			
			template <class E>
			constexpr const E* data(std::initializer_list<E> il) noexcept
			{
				return il.begin();
			}
		4. std::size() has two overloads; for a class C it returns c.size(), and for arrays it returns the size N:
			template <class C>
			constexpr auto size(const C& c) -> decltype(c.size())
			{
				return c.size();
			}
			
			template <class T, std::size_t N>
			constexpr std::size_t size(const T (&array)[N]) noexcept
			{
				return N;
			}
		5. In C++20, the std::ssize() non-member function was added as a companion to std::size() to return the number of elements in a given container or an array as a signed integer.
		6. std::ssize() has two overloads: for a class C it returns c.size() statically cast to a signed integer (typically std::ptrdiff_t) and for arrays it returns N, the number of elements.
	12. Selecting the right standard containers
	
6 General-Purpose Utilities
	1. Expressing time intervals with chrono::duration
		1. using namespace std::chrono_literals;
			auto half_day = 12h;
			auto half_hour = 30min;
			auto half_minute = 30s;
			ms us, ns
		2. Use direct conversion from a lower precision duration to a higher precision duration:
			std::chrono::hours half_day_in_h(12);
			std::chrono::minutes half_day_in_min(half_day_in_h);
		3. Use std::chrono::duration_cast to convert from a higher precision to a lower precision duration:
			using namespace std::chrono_literals;
			auto total_seconds = 12345s;
			auto hours = std::chrono::duration_cast<std::chrono::hours>(total_seconds);
			auto minutes = std::chrono::duration_cast<std::chrono::minutes>(total_seconds % 1h);
			auto seconds = std::chrono::duration_cast<std::chrono::seconds>(total_seconds % 1min);
			auto d1 = 1h + 23min + 45s; // d1 = 5025s
		4. Use the chrono conversion functions floor(), round(), and ceil() available in the std::chrono namespace in C++17 when rounding is necessary.
		5. The default unit is the second, and for expressing other units, such as minutes or milliseconds, we need to use a ratio. 
		6. For units greater than a second, the ratio is greater than one, such as ratio<60> for minutes. For units smaller than a second, the ratio is smaller than one, such as ratio<1, 1000> for milliseconds. 
			typedef duration<long long, ratio<1, 1000>> milliseconds;
			typedef duration<long long> seconds;
			typedef duration<int, ratio<60> > minutes;
		7. However, it is important to note that when two durations of different time units are added or subtracted, the result is a duration of the greatest common divisor of the two time units. This means that if you add a duration representing seconds and a duration representing minutes, the result is a duration representing seconds.
	2. Working with calendars
		1. More clocks, such as a UTC clock, an International Atomic Time clock, a GPS clock, a file time clock, and a pseudo-clock representing local time.
			• Time of day, representing the time elapsed since midnight split into hours, minutes, and seconds.
			Time zones
		2. year_month_day type. // format: year / month /day
			year_month_day d1 = 2024y / 1 / 15;
			year_month_day d2 = 2024y / January / 15;
		3. year_month_weekday
			// format: year / month / weekday
			year_month_weekday d1 = 2024y / January / Monday[1];
			// format: weekday / month / year
			year_month_weekday d2 = Monday[1] / January / 2024;
		4. Determine the current date, as well as compute other dates from it, such as the dates for tomorrow and yesterday:
			auto today = floor<days>(std::chrono::system_clock::now());
			auto tomorrow = today + days{ 1 };
			auto yesterday = today - days{ 1 };
		5. Compute the number of days between two dates:
			inline int number_of_days(std::chrono::sys_days const& first,
			std::chrono::sys_days const& last)
			{
				return (last - first).count();
			}
		6. Check whether a date is valid:
			auto day = 2024y / January / 33;
			auto is_valid = day.ok();
		7. Represent the time of day with hour, minutes, and seconds using the hh_mm_ss<Duration>
			chrono::hh_mm_ss<chrono::seconds> td(13h+12min+11s);
		8. Create time points with date and time parts:
			auto tp = chrono::sys_days{ 2024y / April / 1 } + 12h + 30min + 45s;
		9. The following table lists all these types in the std::chrono namespace and what they represent:
				day
				month
				year
				weekday
				weekday_indexed
				weekday_last
				month_day
				month_day_last
				month_weekday
				month_weekday_last
				year_month
				year_month_day
				year_month_day_last
				year_month_weekday
				year_month_weekday_last
		10. std:chrono::last to indicate the last day of the month
			• weekday[n], to indicate the nth weekday of the month (where n can take values from 1 to 5)
			• weekday[std::chrono::last], to indicate the last weekday of the month
		11. std::chrono::time_point with the precision of a day (24 hours)
		12. Explicit conversion between time_point and sys_days / sys_seconds can be performed using std::chrono::time_point_cast() or std::chrono::floor().\
		13. is_am() and is_pm() that check whether a 24-hour formatted time 
		14. make12() and make24() that return the 12-hour equivalent of a 24-hour format
	3. Converting times between time zones
		1. std::chrono::current_zone(), std::chrono::locate_zone(), 
		2. Represent a time point in a particular time zone using the std::chrono::zoned_time class template
			auto time = zoned_time{ current_zone(), system_clock::now() };
			auto time = zoned_time{ locate_zone("Europe/Rome"), system_clock::now() };
		3. As a user, you cannot create or alter the database but only retrieve a read-only copy of it with functions such as std::chrono::tzdb() or std::chrono::get_tzdb_list()
	4. Measuring function execution time with a standard clock
		1. auto start = std::chrono::high_resolution_clock::now();
		2. steady_clock: This indicates a clock that is never adjusted. 
		3. utc_clock: This is a C++20 clock for Coordinated Universal Time.
			• tai_clock: This is a C++20 clock for International Atomic Time.
			• gps_clock: This is a C++20 clock for GPS time.
			• file_clock: This is a C++20 clock used for expressing file times
		4. The steadiness of a clock is important when measuring the execution time of a function because, if the clock is adjusted while the function runs, the result will not yield the actual execution time, and values can even be negative. 
	5. Generating hash values for custom types
		1. template<>
		struct hash<Item>
		{
			typedef Item argument_type;
			typedef size_t result_type;
			result_type operator()(argument_type const & item) const
			{
				result_type hashValue = 17;
				hashValue = 31 * hashValue + std::hash<int>{}(item.id);
				hashValue = 31 * hashValue + std::hash<std::string>{}(item.name);
				hashValue = 31 * hashValue + std::hash<double>{}(item.value);
				return hashValue;
			}
		}
		2. The use of the prime number 31 is advantageous for performance optimizations because 31 * x can be replaced by the compiler with (x << 5) - x, which is faster. Similarly, you can use 127 because 127 * x is equal to (x << 7) - x or 8191, because 8191 * x is equal to (x << 13) - x.
	6. Using std::any to store any value
		1. Std: : any doesn't take any template argument type
		2. dynamic allocation of memory
		3. auto d = std::any_cast<double>(value);
		4. To check the type of the stored value, use the member function type()
			a.type() == typeid(int);
		5. if(a.has_value())
		6. This function throws std::bad_any_cast if the stored value has a different type than the one you are casting to. Casting between implicitly convertible types, such as int and long, is not possible either. std::bad_any_cast is derived from std::bad_cast;
		7. If you want to store multiple values of any type, use a standard container such as std::vector to hold values of the type std::any
			std::vector<std::any> values;
			values.push_back(std::any{});
			values.push_back(42);
			values.push_back("42"s);
			values.push_back(42.0);
			values.push_back(std::chrono::system_clock::now());
			for (auto const & v : values)
			log(v);
	7. Using std::optional to store optional values
		1. Std:: optional have template parameter where as std::any doesnot have
		2. v1.value(), v2.value_or("default"s), 
		3. To modify the stored value, use the member functions emplace(), reset(), or swap():
		5. The std::optional class template is conceptually implemented like this
			template <typename T>
			class optional
			{
				bool _initialized;
				std::aligned_storage_t<sizeof(t), alignof(T)> _storage;
			}
		6. The std::aligned_storage_t alias template allows us to create uninitialized chunks of memory that can hold objects of a given type. 
		7. NOTE:
			void process(std::optional<bar> const & arg)
			{
			/* do something with arg */
			}
			std::optional<bar> b1{ bar{} };
			bar b2{};
			process(b1); // no copy
			process(b2); // copy construction of bar is invoked, not of std::optional
			because b2 is a bar and needs to be copied to a std::optional<bar>; a copy is made even if bar has move semantics implemented. 
	8. Chaining together computations that may or may not produce a value
		1. These methods are transform(), and_then(), and or_else()
		2. auto b = make_booking("Hotel California", 3, 300);
			b = b.and_then(add_insurance);
			auto p = b.transform(calculate_price);
			auto b = make_booking("Hotel California", 3, 300).or_else(....) // when optional value is empty then it will invoke from else
	9. Using std::variant as a type-safe union
		1. If a union contains values of non-POD types, then these members require explicit construction with a placement new and explicit destruction, which is cumbersome and error-prone. 
		2. std::variant<int, std::string, foo> v = 42; // holds int
			auto i1 = std::get<int>(v);
			auto i2 = std::get<0>(v);
			catch (std::bad_variant_access const & e)
			v.index();
		3. To check whether a variant holds an alternative, use the non-member function std::holds_alternative():
		4. On the other hand, a variant cannot hold an alternative of the type void, or alternatives of array and reference types. Moreover, the first alternative must always be default constructible. 
		5. a variant is default initialized with the value of its first alternative.
	10. Visiting a std::variant
		1. std::visit([](auto&& arg) { std::cout << arg.title << '\n'; }, d);
		2. struct visitor_functor
			{
				void operator()(Movie const & arg) const;
				void operator()(Music const & arg) const;
				void operator()(Software const & arg) const
			};
			std::visit(visitor_functor(), d);
		3. we can do it by lambda overload or by inheritance
		4. 
			for (auto const & d : dvds)
			{
				std::visit([](auto&& arg) {
				using T = std::decay_t<decltype(arg)>;
				if constexpr (std::is_same_v<T, Movie>) ...
				else if constexpr (std::is_same_v<T, Music>) ...
	11. Using std::expected to return a value or an error
		1. We often need to write a function that returns both some data and an indication of success or failure (either as a bool for the simplest case or an error code for more complex cases)
		2. When returning data from a function, return either std::unexpected<E> to indicate an error, or the data (a value of T) when everything is executed successfully:
		3. std::expected<Image, Status>
			return std::unexpected<Status> {Status::InvalidFormat};
			return img;
		4. When checking the result of a function that returns std::expected<T, E>, use the bool operator (or the has_value()
		5. The std::expected<T, E> class template is available in the new C++23 header called <expected>. This class is a mixture of the std::variant and the std::optional types
	12. Using std::span for contiguous sequences of objects
		1. We could say that std::span is to std::vector and array types what std::string_view is to std::string.
		2. header <span>.
		3. void func(int* buffer, size_t length)
			void func(std::span<int> buffer)
			int arr[] = {1, 1, 2, 3, 5, 8, 13};
			std::span<int, 7> s {arr};
		4. subspan() : Retrieves a sub-span with N elements starting from a specified offset. 
		5. A span is not intended to be used with general-purpose algorithms that work with a pair of iterators to the beginning and the end of a range. Its main purpose is to build better interfaces than the C-like ones where a pointer and a size are passed to a function. 
	13. Using std::mdspan for multi-dimensional views of sequences of objects, any sequential data structure can be converted into mdspan, 2,3,4 ... any number of dimensions
		1. In other words, replace functions like this:
			void f(int data[2][3]) { /* … */ }
			void g(int** data, size_t row, size_t cols) { /* … */ }
			void h(std::vector<std::vector<int>> dat, size_t row, size_t cols) { /* … */ }
			with this:
			void f(std::mdspan<int,std::extents<size_t, 2, 3>> data) //compile-time length (called static extent) extents Means dimensions
		2. Create an mdspan with a runtime length (called dynamic extent) by not specifying the number of elements of a dimension of the span at compile-time, and instead providing it at runtime:
			int* data = get_data();
				std::mdspan<int, std::extents<size_t,
				std::dynamic_extent,
				std::dynamic_extent>>;
				
			int* data = get_data();
				std::mdspan<int, std::extents<size_t,
				2,
				std::dynamic_extent>>;
				
				std::mdspan m(data, 2, 3);
		3. To control the mapping of the multi-dimensional indexes of an mdspan to the one-dimensional index of the underlying (contiguous) sequence of data, use a layout policy, which is the third
			template argument:
			std::mdspan<int,
			std::extents<size_t, 2, 3>,
				std::layout_right> mv{ data };
			or
			std::mdspan<int,
			std::extents<size_t, 2, 3>,
				std::layout_left> mv{ data };
			or
			std::mdspan<int,
			std::extents<size_t, 2, 3>,
				std::layout_stride> mv{ data };	
		4. std::array<int, 6> arr;
			std::mdspan m{arr.data(), std::extents{2, 3}};
		5. stride() //Returns the stride of the specified dimension.  //Stride means Jump for next element
		6. The layout policies control how the multi-dimensional index of an mdspan maps to the offset in the one-dimensional underlying data. 
		7. There are several options available: layout_right (the default) where the rightmost index gives stride-one access to the underlying memory (this is the C/C++ style); layout_left where the leftmost index gives stride-one access to the underlying memory (this is the Fortran and Matlab style); and layout_stride, which generalizes the previous two and allows customizing the stride on each extent. The reasons for having layout policies are interoperability with other languages and to change an algorithm’s data access pattern without changing the structure of its loop.
		Means [a][b], whether to consider a as row, or b as column, in similar fashion
		8. The stride of the first extent represents the offset increment for rows. 
			a stride of 2, as in this case, indicates that rows are read from indexes 0, 2, 4, and so on
		9. The stride of the second extent represents the offset increment for columns. 
			, so a stride of 3 for columns means that the elements of the first row will be read from the index 0, 3, and 6. The second row starts at index 2. Therefore, the elements of the second row will be read from the indexes 2, 5, and 8. 
	14. Registering a function to be called when a program exits normally
		1. std::atexit( .... ) 
		2. std::at_quick_exit(
		3. The standard guarantees that at least 32 handlers can be registered with each method, although actual implementations can support any higher number. 
		4. If multiple handlers are registered, then they are called in the reverse order of their registration.
		5. However, it is guaranteed that exit handlers registered before the construction of a static object are called after the destruction of that static object
		6.  exit handlers registered after the construction of a static object are called before the destruction of that static object
	15. Using type traits to query properties of types
		1. std::is_arithmetic_v, std::is_standard_layout_v, std::is_trivial_v
		2. Type traits are classes that provide meta-information about types or can be used to modify types
		3. Traits that provide information about types , is_*
		4. Traits that modify properties of types (such as add_const, remove_const, add_pointer, remove_pointer, make_signed, make_unsigned, and so on).
		5. Custom type traits
			template <typename T>
			struct is_void
			{ static const bool value = false; };
			
			template <>
			struct is_void<void>
			{ static const bool value = true; };
			
		6. The enable_if() type trait defines a type alias for its type template parameter if and only if its non-type template parameter is an expression that evaluates to true:
			template<bool B, typename T = void>
			struct enable_if {};
			
			template<typename T>
			struct enable_if<true, T> { using type = T; };
	16. Writing your own type traits
		1. template <typename T>
			struct is_serializable_with_encoding
			{
				static const bool value = false;
			}
			
			template <>
			struct is_serializable_with_encoding<bar>
			{
				static const bool value = true;
			}
	17. Using std::conditional to choose between types
		1. std::decay to remove const and volatile qualifiers
		2. using long_type = std::conditional_t<sizeof(void*) <= 4, long, long long>;
			auto n = long_type{ 42 }; // it is now long
		3. template <typename T, typename D = std::conditional_t<
						std::is_integral_v<T>,
						std::uniform_int_distribution<T>,
						std::uniform_real_distribution<T>>,
	18. Providing logging details with source_location
		1. std::source_location const location = std::source_location::current()
			location.file_name() << '('
			<< location.line() << ':'
			<< location.column() << ") '"
			<< location.function_name()
	19. Using the stacktrace library to print the call sequence
		1. std::stacktrace::current()
			frame.source_file()
			frame.source_line()
			frame.description()
		2. <stacktrace>. This header contains the following two classes:
			1. std::basic_stacktrace : which is a class template that represents a sequence container of stack trace entries
			2. std::stacktrace_entry, which represents an evaluation in a stack trace
			3. When discussing the call sequence, there are two terms that need to be correctly understood: call stack and stack trace. A call stack is the data structure used to store information about the active frames (calls) in a running program. A stack trace is a snapshot, at some moment in time, of the call stack.

7 Working with Files and Streams
	1. Reading and writing raw data from/to binary files
		1.To determine the number of characters that have been successfully read from the stream, we can use the gcount()
		2. ifile.seekg(0, std::ios_base::end); //offset from end position 0 means move to end
		3. Initializing a std::vector directly using std::istreambuf_iterator iterators 
			input = std::vector<unsigned char>(
				Working with Files and Streams
				std::istreambuf_iterator<char>(ifile),
				std::istreambuf_iterator<char>());
			using std::istreambuf_iterator initializing vector
	2. Reading and writing objects from/to binary files
		1.	the end of the file has not yet been encountered (as that is a mark beyond the last byte of the file). The end of the file mark is only reached at the next read attempt, which, therefore, sets the eofbit of the stream. 
	3. Using streams on fixed-size external buffers
		1.	In C++23, a new header, <spanstream>, has been added as a replacement for <strstream>2. char text[] = "1 1 2 3 5 8";
			std::ispanstream is{ std::span<char>{text} };
			int value;
			while (is >> value)
			{
				std::cout << value << '\n';
			}
		3.  stream operations on sequences of characters stored in an array. 
		4. std::ws is an I/O manipulator that discards whitespaces from an input stream.
			char const text[] = "severity=1,code=42,message=generic error";
			std::unordered_map<std::string, std::string> m;
			std::string key, val;
			std::ispanstream is(text);
			while (std::getline(is, key, '=') >> std::ws)
			{
				if(std::getline(is, val, ','))
				m[key] = val;
			}
	4. Using localized settings for streams
		1.	how to use locales to control the behavior of input/output streams.
			auto sort_and_print = [](std::vector<std::string> v,
			std::locale const & loc)
			{
				std::sort(v.begin(), v.end(), loc);
			};
		2. Use the std::locale class to represent the localization settings. 
		3. auto loc_us = std::locale {"en_US.utf8"};
			• To get a copy of the default C locale, use the std::locale::classic() static method:
				auto loc = std::locale::classic();
			• To change the default locale that is copied every time a locale is default-constructed, use the
				std::locale::global() static method:
				std::locale::global(std::locale("en_US.utf8"));
			• Use the imbue() method to change the current locale of an I/O stream:
				std::cout.imbue(std::locale("en_US.utf8"));
		4. A locale is a heterogeneous container of facets. A facet is an object that defines the localization and internationalization settings. The standard defines a list of facets that each locale must contain.
		5. std::money_get is a facet that encapsulates the rules for parsing monetary values from character streams
		6. std::money_put is a facet that encapsulates the rules for formatting monetary values as strings. 
		7. Read from book for more details
	5. Using I/O manipulators to control the output of a stream
		1.	std::boolalpha, std::noboolalpha, ...
	6. Using monetary I/O manipulators
		1.	std::cout.imbue(std::locale("en_GB.utf8"));
		2. long double mon = 12345.67;
		std::cout << std::showbase << std::put_money(mon)//// £123.46
		std::cout << std::showbase << std::put_money(mon, true) << '\n'; // GBP 123.46
	7. Using time I/O manipulators
		1.	std::cout << std::put_time(ltime, "%F") << '\n'; // // 2016-12-04
			std::put_time(ltime, "%FT%T%z") << '\n' //// 2016-12-04T05:26:47+0900
			std::put_time(ltime, "%T") << '\n'; //// 05:26:47
			
			std::istringstream stext("2016-12-04T05:26:47+0900");
			stext >> std::get_time(&time, "%Y-%m-%dT%H:%M:%S");
	8. Working with filesystem paths
		1.	auto path = fs::path{"C:\\Users\\Marius\\Documents"};
			path = path / "Modern" / "Cpp";
			path += "\\Book";
		2. Decompose the elements of a path into its parts, such as the root, root directory, parent path, filename, extension, and so on, using member functions such as root_name(), root_dir(), filename(), stem(), extension(), and so on
		3. Query whether parts of a part are available using
			path.has_root_name() << '\n
			path.has_root_directory() << '\n'
			path.has_root_path() << '\n'
			....
	9. Creating, copying, and deleting files and directories
		1.	auto success = fs::create_directory(path, err);
			fs::current_path();
			fs::rename(temp, newtemp, err);
			fs::copy(path, basepath / "temp2", fs::copy_options::recursive, err);
			fs::remove, fs::remove_all, fs::permissions
	10. Removing content from a file
		1.	On Windows systems, this function returns the same directory as GetTempPath(). On POSIX systems, it returns the path specified in one of the environment variables TMPDIR, TMP, TEMP, or TEMPDIR, or, if none of them are available, it returns the path /tmp.
	11. Checking the properties of an existing file or directory
		1.	fs::exists, fs::equivalent, fs::last_write_time, fs::size, fs::hard_link_count
			(p & fs::perms::owner_read)
			(p & fs::perms::owner_write)
			......
		2. auto status = fs::status(path, err);
			print_perm(status.permissions());
	12. Enumerating the content of a directory
		1.	for (auto const & entry : fs::directory_iterator(dir))
			for (auto const & entry : fs::recursive_directory_iterator(dir))
	13. Finding a file
		1. same as boost, is_file, is_dir etc.
		
8 Leveraging Threading and Concurrency
	1. Working with threads
	2. Synchronizing access to shared data with mutexes and locks
		1. std::this_thread::yield();
			std::this_thread::sleep_for(2s); //Note the use of yield and then sleep followed by it
		2. recursive_*, recursive_timed_*, shared_*
		3. unique_lock, for deferred locking
			shared - for read/write
			scope_lock -  for std::lock usage
		4. std::lock_guard<std::mutex> l1(c1.mutex, std::adopt_lock); 
			std::scoped_lock lock(c1.mutex, c2.mutex); //deadlock avoidance 
	3. Finding alternatives for recursive mutexes
	4. Handling exceptions from thread functions
		1. exceptions can be transported between threads within a std::exception_ptr wrapper. 
			g_exceptions.push_back(std::current_exception());
			std::rethrow_exception(g_exceptions);
	5. Sending notifications between threads
		1. std::condition_variable_any, works with any lock
	6. Using promises and futures to return values from threads
		1. std::promise<int> p;
			std::thread t1(produce_value, std::ref(p));
			std::future<int> f = p.get_future();
			std::thread t2(consume_value, std::ref(f));
			
			p.set_exception(std::current_exception());
			std::cout << f.get() << '\n';
	7. Executing functions asynchronously
		1. auto f = std::async(std::launch::async, do_something);
			f.wait();
			
			auto status = f.wait_for(500ms);
			if(status == std::future_status::ready)
	8. Using atomic types
		1. In C++20, use the std::atomic_ref
		2. Use the std::atomic_flag class for an atomic Boolean type:
		3. std::atomic_flag lock = ATOMIC_FLAG_INIT;
		4. while(lock.test_and_set(std::memory_order_acquire)); // for acquiring lock
			lock.clear(std::memory_order_release); // releasing
		5. Use the atomic type’s members – load(), store(), and exchange() – or non-member functions – atomic_load()/atomic_load_explicit(), atomic_store()/atomic_store_explicit(), and atomic_exchange()/atomic_exchange_explicit() – to atomically read, set, or exchange the value of an atomic object.
		6. Use its member functions fetch_add() and fetch_sub() or non-member functions atomic_fetch_add()/atomic_fetch_add_explicit() and atomic_fetch_sub()/atomic_fetch_sub_explicit() to atomically add or subtract a value to/from an atomic object and return its value before the operation:
		7. fetch_ operation returns previous value
		8. std::atomic_fetch_add_explicit : these functions have an extra argument that represents the memory order.
		9. In C++20, perform thread synchronization with member functions wait(), notify_one(), and notify_all(), available to std::atomic, std::atomic_ref, and std::atomic_flag, as well as the non-member functions atomic_wait()/atomic_wait_explicit(), atomic_notify_one(), and atomic_notify_all(). 
		10. In C++20, partial specializations such as std::atomic<std::shared_ptr<U>> for std::shared_ptr and std::atomic<std::weak_ptr<U>> for std::weak_ptr.
		11. exchange() to atomically store a non-atomic value in the object and return the previous value.
		12. std::atomic_flag, which is guaranteed to be lock-free.
		13. Prior to C++20, the only way to initialize a std::atomic_flag to a definite value was by using the ATOMIC_FLAG_INIT macro. This initializes the atomic flag to the clear (false) value:
			std::atomic_flag lock = ATOMIC_FLAG_INIT;
		In C++20, this macro has been deprecated because the default constructor of std::atomic_flag
		initializes it to the clear state
	9. Implementing parallel map and fold with threads
		1. In functional programming, a "parallel map" applies a function to each element of a collection simultaneously across multiple processors, essentially performing the operation in parallel, while a "fold" iteratively combines elements of a collection into a single value using a cumulative result, essentially "folding" the data together; the key difference is that "map" produces a new collection with transformed elements, whereas "fold" results in a single value by accumulating information from the collection.
	10. Implementing parallel map and fold with tasks
	11. Implementing parallel map and fold with standard parallel algorithms
		1. Note Std:: transform or map function modify value  where as std:: reduce function produce new single value as a result
		2. Vectorization is the process of transforming an algorithm so that instead of working on a single value at a time it would work on a set of values (vector) at the same time. Modern processors provide this at a hardware level through SIMD (Single Instruction, Multiple Data) units.
		3.std::reduce - An out-of-order version of std::accumulate().
		4. std::transform_reduce - Applies a function to the elements of a range then accumulates the elements of the resulting range out of order (that is, reduces).
		5. 
		// sequential
			auto sums = std::transform_reduce( std::begin(v), std::end(v),
												std::plus<>(),
												[](int const i) {return i + i; } );
		// parallel
			auto sump = std::transform_reduce(
			std::execution::par,
			std::begin(v), std::end(v),
			0LL,
			std::plus<>(),
			[](int const i) {return i + i; });
	12. Using joinable threads and cancellation mechanisms
		1. std::jthread, std::stop_token
	13. Synchronizing threads with latches, barriers, and semaphores
		1. The new C++20 synchronization mechanisms are defined in new headers. You have to include <latch> for std::latch, <barrier>, or std::barrier, and <semaphore> for std::counting_semaphore and std::binary_semaphore.
		2. The std::latch class implements a counter that can be used to synchronize threads. It is a race-free, only used once, barrier support completion point and reuse of it.
			class that works as follows:
			• The counter is initialized when the latch is created and can only be decreased.
			• A thread may decrease the value of the latch and can do so multiple times.
			• A thread may block by waiting until the latch counter reaches zero.
			• When the counter reaches zero, the latch becomes permanently signaled and all the threads
			that are blocked on the latch are awakened
		count_down() try_wait() wait() arrive_and_wait()
		3. Semaphore, std::counting_semaphore<N>, std::binary_semaphore
			acquire(), try_acquire(), try_acquire_for(),  try_acquire_until().  release()
		4. 
	14. Synchronizing writing to output streams from multiple threads
		1. no need of exclusive synchronisation just use the wrapper
		std::jthread([](const int id)
		{
			std::osyncstream scout{ std::cout };
			scout << "thread " << id << " running\n";
		}, i));
		2. By default, the standard C++ stream objects std::cin/std::wcin, std::cout/std::wcout, std::cerr/ std::wcerr, and std::clog/std::wclog are synchronized with their respective C streams, stdin, stdout, and stderr (unless a call to std::ios_base::sync_with_stdio()
		3. Moreover, accessing these streams is guaranteed to be thread-safe. This means that calls to operator << or >> are atomic; another thread cannot access the stream until the call completes.
		4. In C++20, you can use a std::osyncstream/std::wosyncstream object to wrap an output stream to synchronize access, as shown in the How to do it… section. The osyncstream class guarantees there are no data races if all the write operations from different threads occur through instances of this class. The std::basic_osyncstream class wraps an instance of std::basic_syncbuf, which, in turn, wraps an output buffer but also contains a separate internal buffer. This class accumulates output in an internal buffer and transmits it to the wrapped buffer when the object is destructed or when an explicit call to the emit() member function occurs. it is just RAII which flush at time of destruction until then Keep it in internal buffer
		5. 
			int main()
			{
				std::ostringstream str{ };
				{
					std::osyncstream syncstr{ str };
					syncstr << "sync stream demo";
					std::cout << "A:" << str.str() << '\n'; // [1]
					{
						std::osyncstream syncstr2{ syncstr.get_wrapped() };
						syncstr2 << "demo part 3";
						std::cout << "B:" << str.str() << '\n'; // [2]
					}
					std::cout << "C:" << str.str() << '\n'; // [3]
				}
				std::cout << "D:" << str.str() << '\n'; // [4]
			}
			
			Output: 
			
			A:
			B:
			C:demo part 3
			D:demo part 3sync stream demo
			
			The first sync stream to be destroyed is syncstr2, at the end of the second inner block. Therefore, on the line marked with [3], the content of the string stream will be "demo part 3". Then, the first sync stream object, syncstr, goes out of scope at the end of the first inner block, adding the text "sync stream demo" to the string stream. 
		
9 Robustness and Performance
	1. Using exceptions for error handling
		1. throw std::system_error(std::make_error_code(std::errc::timed_out));
	2. Using noexcept for functions that do not throw exceptions
	
	3. Ensuring constant correctness for a program
	
	4. Creating compile-time constant expressions
	
	5. Creating immediate functions
	
	6. Optimizing code in constant-evaluated contexts
	
	7. Using virtual function calls in constant expressions
	
	8. Performing correct type casts
	
	9. Implementing move semantics
	
	10. Using unique_ptr to uniquely own a memory resource
	
	11. Using shared_ptr to share a memory resource
	
	12. Consistent comparison with the operator <=>
	
	13. Comparing signed and unsigned integers safely
	
10 Implementing Patterns and Idioms
	1. Avoiding repetitive if-else statements in factory patterns
	
	2. Implementing the pimpl idiom
	
	3. Implementing the named parameter idiom
	
	4. Separating interfaces and implementations with the non-virtual interface idiom
	
	5. Handling friendship with the attorney-client idiom
	
	6. Static polymorphism with the curiously recurring template pattern
	
	7. Adding functionality to classes with mixins
	
	8. Handling unrelated types generically with the type erasure idiom
	
	9. Implementing a thread-safe singleton
	
11 Exploring Testing Frameworks
	1. Getting started with Boost.Test
	
	2. Writing and invoking tests with Boost.Test
	
	3. Asserting with Boost.Test
	
	4. Using test fixtures with Boost.Test
	
	5. Controlling output with Boost.Test
	
	6. Getting started with Google Test
	
	7. Writing and invoking tests with Google Test
	
	8. Asserting with Google Test
	
	9. Using test fixtures with Google Test
	
	10. Controlling output with Google Test
	
	11. Getting started with Catch2
	
	12. Writing and invoking tests with Catch2
	
	13. Asserting with Catch2
	
	14. Controlling output with Catch2
	
12 C++ 20 Core Features
	1. Working with modules
	
	2. Understanding module partitions
	
	3. Specifying requirements on template arguments with concepts
	
	4. Using requires expressions and clauses
	
	5. Exploring abbreviated function templates
	
	6. Iterating over collections with the ranges library
	
	7. Exploring the standard range adaptors
	
	8. Converting a range to a container
	
	9. Creating your own range view
	
	10. Using constrained algorithms
	
	11. Creating a coroutine task type for asynchronous computations
	
	12. Creating a coroutine generator type for sequences of values
	
	13. Generating a sequence of values with the std::generator type