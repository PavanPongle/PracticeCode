Chaper 1 : Introduction
	1.  The zero-overhead principle
		What you don't use, you don't pay for
		What you do use, you couldn't hand code any better
		
2. Essential C++ Techniques
	1. A forwarding reference
		auto&& is called a forwarding reference (also referred to as a universal reference)
		Forwarding references will, just like const references, extend the lifetime of a temporary
		auto&& allows us to mutate objects it references, temporaries included
	2.  std::experimental::propagate_const
		To prevent modification under the const function, using pointer
		Note that propagate_const only applies to pointers, and pointer-like classes such as std:shared_ptr and std::unique_ptr, but not std::function
			#include <experimental/propagate_const> &
			std::experimental::propagate_const<int*> ptr_ = nullptr;
	3.  auto b = std::move(a); // Tell the compiler to move the resource into b
	4. Rule of 3:  The copy-constructor, copy-assignment, and destructor, all or none
	5. Note, how ref member can be copy or moved 
		
		private: 
		  size_t size_{0}; 
		  float* ptr_{nullptr};
		  int& ref_;
	
		// 1. Copy constructor 
		Buffer::Buffer(const Buffer& other) : size_{other.size_}, ref_{other.ref_} { 
		  ptr_ = new float[size_]; 
		  std::copy(other.ptr_, other.ptr_ + size_, ptr_); 
		} 
		// 2. Copy assignment 
		auto& Buffer::operator=(const Buffer& other) {
		  delete [] ptr_;
		  ptr_ = new float[other.size_];
		  size_ = other.size_;
		  std::copy(other.ptr_, other.ptr_ + size_, ptr_);
		  return *this;
		}
		// 4. Move constructor
		Buffer::Buffer(Buffer&& other) noexcept : size_{other.size_}, ptr_{other.ptr_}, , ref_{other.ref_} {
		  other.ptr_ = nullptr;
		  other.size_ = 0;
		}
		// 5. Move assignment
		auto& Buffer::operator=(Buffer&& other) noexcept {
		  ptr_ = other.ptr_;
		  size_ = other.size_;
		  other.ptr_ = nullptr;
		  other.size_ = 0;
		  return *this;
		}
	6. Do not forget to mark your move-constructors and move-assignment operators as noexcept (unless they might throw an exception, of course). Not marking them noexcept prevents standard library containers and algorithms from utilizing them, instead resorting to using a regular copy/assignment under certain conditions.
	7. Named variables and rvalues
		1.  the compiler moves an object when the object can be categorized as an rvalue.
		2.  rvalue it is just an object that is not tied to a named variable
		3.  We make a variable an rvalue by using std::move()
		4.  str is declared const and therefore is not allowed to mutate:
        const auto str = get_ok();
		button.set_title(std::move(str));  // copy-assigned
	8. Default move semantics and the rule of zero
		1. Writing an empty destructor can prevent the compiler from implementing certain optimizations
		2. However, if we remove the destructor or declare the destructor default, the compiler optimizes std::copy() to utilize memmove() instead of a loop:
		3. Using std::swap we can implement move constructor, but for move assignment it may not be always correct case or expected
		4.  member function that has the && modifier will only be considered by overload resolution if the object is an rvalue
			ex. auto func() && {}
			//usage
			auto a = Foo{}; 
			a.func();            // Doesn't compile, 'a' is not an rvalue 
			std::move(a).func(); // Compiles 
			Foo{}.func();        // Compiles
		5. return std::move(x);  // Don't, RVO is prevented
		 This usage of std::move() prevents the compiler from using return value optimization (RVO)
		6. C++ has no built-in support for contracts yet, but there is ongoing work to add it to future versions of C++. Use a library such as Boost.Contract.
		7. static_assert() or the assert() macro from the <cassert> header.
		8. the only way to signal errors from constructors is by using exceptions.
		9. A function marked with noexcept makes it possible for the compiler to generate faster code in some cases
		10. The size of the binary program is increased even if exceptions are not being thrown.
	9. function call operator of a lambda is const by default, so we explicitly need to specify that the lambda can mutate its members by using the mutable keyword
	10. auto lambda = +[](int result, const char* str) {} This way, the lambda is converted into a regular function pointer.
	11. Lambdas, the compiler has the ability to inline the function call; The flexible design of std::function make it nearly impossible for the compiler to inline a function wrapped in
	12. If a std::function use local buffer optimization, if not possible then use heap, it use memory to store the captured variables.
	13. Lambdas internally uses type erasure 
	14. Generic lambda
		// Using auto
		auto x = [](auto v) { return v + 1; };
		// Using typename
		auto y = []<typename Val>(Val v) { return v + 1; };
		
		
3 Analyzing and Measuring Performance